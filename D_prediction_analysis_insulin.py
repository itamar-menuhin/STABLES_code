#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
prediction_analysis_insulin.py - Insulin Gene Prediction and Downstream Filtering Analysis

This module processes predicted gene expression values generated by the model application 
module (e.g. from KNN and XGB models) and integrates additional gene-specific data. 
It performs the following steps:
    1. Loads predictions from KNN and XGB models.
    2. Ranks genes based on prediction (lower rank indicates stronger prediction).
    3. Merges predictions with codon usage bias (CUB) features and annotation data.
    4. Computes additional metrics such as GC content and gene length.
    5. Applies various biological criteria to filter the gene set.
    6. Adds subsequence pair count feature for further filtering.
    7. Resets indices and saves the final filtered dataset to an Excel file.

Author: Itamar Menuhin-Gruman
Affiliation: Tel Aviv University
Email: imenuhin@gmail.com
Date: 13.4.2025
License: [License Type]
"""

import pandas as pd
from os import path
from collections import Counter


def calc_GC(seq):
    """Return the GC content of a nucleotide sequence."""
    return (seq.count('G') + seq.count('C')) / len(seq)


def calc_len(seq):
    """Return the length of the nucleotide sequence."""
    return len(seq)


def count_pairs_of_subsequences(s, length):
    """Count total pairs of subsequences of a given length in string s."""
    if len(s) < length:
        return 0
    counts = Counter(s[i:i+length] for i in range(len(s) - length + 1))
    return sum(c * (c - 1) // 2 for c in counts.values())


def filter_by_subsequence_pair_count(df, length):
    """
    Add a new column with pair counts (for subsequences of specified length) computed from the ORF.
    """
    col_name = f"pairs_of_length_{length}"
    df[col_name] = df["ORF"].apply(lambda x: count_pairs_of_subsequences(x, length))
    return df[df[col_name] == 0]


# Process predictions from KNN
df_KNN = pd.read_csv("predictions_KNN.csv", index_col=0)
df_KNN = df_KNN.sort_values("prediction_mean", ascending=False)[["prediction_mean"]]
df_KNN = df_KNN.reset_index(names="gene").rename(columns={"prediction_mean": "prediction_KNN"})
df_KNN["ranking_KNN"] = range(df_KNN.shape[0])

# Process predictions from XGB
df_XGB = pd.read_csv("predictions_XGB.csv", index_col=0)
df_XGB = df_XGB.sort_values("prediction_mean", ascending=False)[["prediction_mean"]]
df_XGB = df_XGB.reset_index(names="gene").rename(columns={"prediction_mean": "prediction_XGB"})
df_XGB["ranking_XGB"] = range(df_XGB.shape[0])

# Merge predictions and compute summed rank
df_both = pd.merge(df_KNN, df_XGB, on="gene")[["gene", "ranking_KNN", "ranking_XGB"]]
df_both["sum_ranks"] = df_both.ranking_KNN + df_both.ranking_XGB
df_both = df_both.sort_values("sum_ranks")

# Merge with CUB features
df_CUB = pd.read_csv("../../feature_matrices/yeast_insulin.csv", delimiter="\t", 
                     usecols=["gene", "CAI_he", "CAI_all", "tAI"])
for col in ["CAI_he", "CAI_all", "tAI"]:
    df_CUB_curr = df_CUB[["gene", col]].sort_values(col, ascending=False)
    df_CUB_curr.loc[:, f"ranking_{col}"] = range(df_CUB_curr.shape[0])
    df_both = pd.merge(df_both, df_CUB_curr[["gene", f"ranking_{col}"]], on="gene", how="left")

# Merge with annotation data
df_annot = pd.read_csv("annot.csv", names=["gene", "description", "ORF"])
df_both = pd.merge(df_both, df_annot, on="gene")

# Compute additional features: GC content and ORF length
df_both.loc[:, "GC_content"] = df_both.ORF.apply(calc_GC)
df_both.loc[:, "ORF_length"] = df_both.ORF.apply(calc_len)

# Filter the dataset based on biological criteria
df_filtered = df_both[df_both.GC_content < 0.7]
df_filtered = df_filtered[df_filtered.ORF_length < 500]
df_filtered = df_filtered[df_filtered.ranking_KNN < 666]
df_filtered = df_filtered[df_filtered.ranking_XGB < 333]
df_filtered = df_filtered[df_filtered["description"].apply(lambda x: x.find("induced") == -1)]
df_filtered = df_filtered[df_filtered["description"].apply(lambda x: x.find("ribosom") == -1)]

# Add subsequence pair count with subsequences of length 11 and reset indices
df_filtered = filter_by_subsequence_pair_count(df_filtered, 11)
df_filtered = df_filtered.reset_index(names="old_rank").reset_index(names="new_rank")

# Save the final filtered gene dataset
df_filtered.to_excel("genes_filtered.xlsx")
